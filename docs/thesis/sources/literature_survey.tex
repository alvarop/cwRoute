\section{Previous Work}\label{section:litsurvey}
\subsection{Time Synchronization}
Time synchronization has been the subject of research for many years.

There are robust and time-tested synchronization methods, such as the Network Time Protocol (NTP)~\cite{synchronization:NTP}, which are currently in use around the world. Unfortunately these methods were designed for wired systems, and do not perform well once power consumption, latency, and other wireless effects taken into account. 

One of the first synchronization protocols designed specifically for wireless networks is Reference Broadcast Synchronization (RBS)~\cite{synchronization:RBS}. The main idea behind RBS is to synchronize all wireless sensor nodes to each other. This creates a local time, within the network of nodes, where all clocks are synchronized. For many applications, sensor nodes do not need to know the actual time, as long as they are synchronized to one another. \cite{synchronization:RBS} lists an example application that measures the time-of-flight of sound. If needed, RBS can be extended to use an external global time source to provide a relate the local and global times.

There are several sources of nondeterminism in a wireless network. ~\cite{synchronization:RBS} and ~\cite{synchronization:FTSP} decompose the sources of nondeterminism into several components. These components account for the delays due to the sending and receiving of a message in a wireless network. These components(from ~\cite{synchronization:RBS}) are: 
\begin{itemize}
\item \emph{Send Time} -- Time the sender takes to construct a message. Includes delays incurred by the operating system and time required to transfer the message from the host to the network interface.
\item \emph{Access Time} -- Time spent waiting for access to transmit channel.
\item \emph{Propagation Time} -- Time taken by the message to physically travel from sender to receiver.
\item \emph{Receive Time} -- Time spent processing a message and notifying the host of its arrival.
\end{itemize}

As suggested by its name, RBS uses broadcast messages to synchronize wireless nodes to one another. RBS does not synchronize a set of wireless nodes to a reference clock. Because of this property, RBS effectively eliminates the \emph{Send Time} and \emph{Access Time} as sources of error. The \emph{Access Time}, while unknown, is the same across all devices for any single message. RBS does not take \emph{Propagation Time} into account and considers it to be effectively zero. This is only a valid assumption if all nodes are equidistant from the broadcast message source. As stated in~\cite{synchronization:VHT}, the main benefit of RBS was due to high transmission nondeterminism. With new radio technology, this is no longer the main problem.

RBS is expandable for multi-hop networks, but has several requirements to do so. The first is that there must be multiple broadcast transmitters in order to cover the whole network. This creates several sub-networks of synchronized nodes, but does not synchronize them all together. The second requirement is that there must be a sort of overlap between broadcast transmitters. A sensor node receiving broadcasts from two different transmitters can compute the offset between the local times of both networks. 
\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.4\textwidth]{figures/RBS_multihop.pdf}
\end{center}
\caption{RBS Multi-Hop Network Layout. From~\cite{synchronization:RBS}.}
\label{fig:RBS_multihop}
\end{figure}

Another time synchronization protocol introduced in~\cite{synchronization:TPSN} is the Timing-sync Protocol for Sensor Networks (TPSN). In contrast to RBS, TPSN synchronizes a set of notes to a single global time source. A hierarchical structure is established before synchronization can take place. Once the structure is in place, the root node begins to synchronize all nodes directly connected to it. Those nodes then do the same for their children nodes, etc...

TPSN utilizes the sender-receiver approach~\cite{synchronization:NTP} to synchronize a pair of nodes. A two-way message exchange provides enough information to calculate the clock difference and propagation delay between a pair of nodes. In order to synchronize the whole network, the root node initiates the process. In order to reduce packet collisions, each child node waits for a random amount of time before synchronizing to the parent. This is then repeated with the next level of nodes until they are all synchronized. Due to the very structured nature of TPSN, special protocols are provided for dealing with dying nodes, as well as newly introduced ones.

One of the costs of using TPSN over RBS is that the \emph{Send Time} is once again a source of error in the system. This is, however, mitigated by closely integrating TPSN at the Medium Access Control (MAC) layer. TPSN requires that both incoming and outgoing messages be timestamped at the MAC level in order to minimize uncertainties in transmit and receive times. 

The Flooding-Time Synchronization Protocol (FTSP)~\cite{synchronization:FTSP} is another protocol specifically designed for resource limited wireless platforms. Like TPSN, FTSP relies on MAC-layer time-stamping, along with several other new techniques, to synchronize devices. FTSP uses a single message to synchronize the clocks of to wireless nodes. By comparison, RBS uses a single message to synchronize the clocks of several devices to one-another, but not to the senders clock. TPSN uses two messages to synchronize two device clocks. Because of this, FTSP needs to account to other sources of error, such as the \emph{Byte Alignment Time}. All three protocols are susceptible to the jitter in \emph{Interrupt Handling Time}.

In FTSP, each device sends a broadcast message with its clock time. Devices in the vicinity listen to the broadcast and calculate the difference between their local and received times. In order to reduce jitter, FTSP records multiple times to compute a singe, more accurate time-stamp. This occurs on both the sending and receiving sides. 

Another important contribution from FTSP is a method to deal with clock drift. Due to differences in the exact frequency between local clocks, the time-difference between them grows over time.~\cite{synchronization:FTSP} proposes a solution that takes place off-line. In the short-term, the clock drift is fairly linear. Because of the linear fashion of clock drift, linear regression can be used to distribute the error over a period of time. If clocks are being synchronized every \emph{X} seconds, and clocks drift some amount \emph{Y}, the algorithm distributes the drift \emph{Y} over all samples in a \emph{X} second interval. The reason this must be done off-line is because \emph{Y} can only be computed after each synchronization. 

FTSP scales well to multi-hop wireless networks. Reference points are utilized to keep track of the time differences between the root node and the local node. FTSP is also resistant against losing nodes as it includes root  re-election protocols in case the root node fails. According to ~\cite{synchronization:VHT}, FTSP is currently the \emph{de facto} time synchronization protocol in wireless sensor networks.

The Gradient Time Synchronization Protocol (GTSP)~\cite{synchronization:GTSP} focuses on synchronization of close-by nodes in multi-hop networks. If two physically nearby nodes are part of two different synchronization trees, their clocks might be different. GTSP uses radio broadcasts overheard from all neighbors in order to provide a more accurate time in relation to close-by nodes.

There are certain disadvantages to each of these methods. RBS requires additional messages for time synchronization across multi-hop networks. TPSN does not account for the clock drift of sensor nodes. Both RBS and TPSN are vulnerable to jitter in interrupt handling and decoding times. While FTSP accounts for interrupt handling jitter, it does not take propagation time into account. This is not a problem if nodes are physically close, but can affect performance in long distance cases. GTSP and RBS are also vulnerable to propagation delay errors.

\subsection{Synchronized Sampling}
There are several applications, such as monitoring an active volcano ~\cite{applications:volcano}, structural monitoring~\cite{applications:structural} and counter sniper systems~\cite{applications:sniper}, which rely on synchronized measurements across sensor networks. Currently there is not much research focusing specifically on synchronized sampling in low-power WSNs. Apart from ~\cite{sampling:earthquake}, most research utilizes the previously described time synchronization protocols to keep device clocks aligned. With synchronized clocks, synchronized sampling is no longer a complex problem.

\subsection{Routing and Relaying}
Due to power and physical constraints, sensor nodes placed along the body may not be able to communicate with the main node directly. Even when sensor nodes are able reach the main node, the power required to do so could be prohibitive. The use of relays to re-transmit the data has been shown to dramatically reduce power consumption in body sensor networks~\cite{relay:creepingwave}.

There are several routing protocols currently used in WSNs~\cite{survey:wirelessrouting}, unfortunately, most are not well suited for BSNs. Several of the protocols focus on mobility, Quality of Service (QoS), scalability and reliability, among other things. In general, BSNs do not have the same requirements as other WSNs. For example, in BSNs, scalability is no longer a problem since networks are limited to a human body. In most cases, power consumption becomes the main limiting factor for overall system performance. 

Some routing protocols are specifically designed with BSN constraints in mind. One example is the Wireless Autonomous Spanning tree Protocol (WASP) \cite{protocol:WASP}. Braem et al. describe the WASP as ``a slotted protocol that uses a spanning tree for medium access coordination and traffic routing''. The main idea is that each node sends a ``WASP-scheme'' through a broadcast message that both parent and children nodes receive. This scheme contains the time allotments for each node for the current time frame. The children of the current node need the scheme to know when they are allowed to transmit data. The scheme also informs the parent of the current node as to how many children each node has, which allows it to allocate enough time slots for that branch. This method allows for a distributed time-allocation protocol. Each time frame also includes contention periods where new nodes can join the network. Routing is simple as data from sensor nodes is just sent up the network tree and broadcast messages are used to send configuration down from the root node. The main disadvantage of the WASP is the need to send the scheme packets from the root node down the tree during every time frame.

An improvement over the WASP is the Cascading Information retrieval by Controlling Access with Distributed slot Assignment (CICADA) protocol~\cite{protocol:CICADA}. The improvement over the WASP has to do with the separation of control and data subcycles. The WASP re-configures the time slots during every frame, which produces a significant time delay. The information has to move from the root node to all the children and back. The CICADA protocol configures the network in a separate subcycle and later transfers data. The data transfer is initiated from the bottom of the tree, so there is no delay waiting for the root node to send configurations down during each data subcycle.

Other BSN routing methods focus on postural mobility~\cite{routing:storeandforward}. Quwaider et al. propose a protocol tolerant to constant network changes due to body/sensor movement. When sensor nodes are located in body extremities, the wireless links vary with body position changes. The proposed protocol uses a store-and-forward method to transfer data from sensor nodes to the main node. While the protocol is well suited for dealing with mobile nodes, it requires more energy to do so. ``Hello'' packets are constantly sent by each node to determine what the current neighboring nodes are. A neighbor table is generated using this information and is necessary to determine where packets will be sent to. Another problem with the method is due to multiple copies of packets being transmitted to increase the probability of delivery. Finally, the main node transmits at full power in order to poll each sensor node, increasing its energy consumption.

Most current routing methods for BSNs use network trees. One of the main problems present with network trees is that the nodes closer to the main node deplete their energy supply faster than children nodes. This is due to the fact that all trafic from children nodes has to be relayed through. Ehyaie et al. propose using dedicated relay nodes instead of having sensor nodes act as relays~\cite{relay:networklife}. Using dedicated relays increases the individual sensor life, with the added cost of more devices.

So far, most BSNs have used tree-like networks to join nodes together. Tree networks, while simple, are negatively affected by node failures and movement.  Nabi et al. use a gossiping data routing strategy along with TDMA based MAC to transmit information to the main node \cite{relay:transmitpoweradaptation}. Each node receives and stores the last sample data from every neighboring node. During transmission, it sends its own sampled data, along with one or more of the stored packets from other nodes. This method maximizes the likelihood of a packed reaching the main node, while consuming more power due to retransmissions of the same data. Timestamps are used to decide whether or not a received packed will be stored or discarded. The main node is assumed to have higher battery capacity and transmission range. It is required to be able to reach all nodes with a single transmission. It is in charge of sending a synchronization beacon to use as a time reference for TDMA frames. This method is not always feasible, for example, when two nodes are on opposite sides of the body.

Another valuable contribution from~\cite{relay:transmitpoweradaptation} deals with Transmit Power Adaptation (TPA). The goal for TPA is to minimize power consumption while maintaining a specific link quality. It achieves this goal by adjusting Tx power according to link quality. Unlike the link quality metric in ~\cite{routing:storeandforward}, which was bidirectional, nodes have both inlink and outlink qualities. The outlink metric is then maintained within predefined thresholds by varying Tx power. Inlink quality is stored and later transmitted in order to share the information with neighboring nodes.

%\subsection{Similar Work}
%In order to determine the improvements of novel methods, reference systems need to be available to compare with. Both~\cite{mac:tdma}~and~\cite{mac:lowdutycycle} provide a suitable reference system for a synchronized, non-relaying BSN. Both proposed systems present, in detail, a TDMA MAC protocol specifically designed with energy efficiency in mind. Details of packet format, TDMA frame calculation, and power consumption measurements are available.
%Add more details later

%[The current system is further simplified by the complete determinism of network traffic. Each sensor node is continuously sampling data at a known rate and sending it back to the main node at known intervals. This allows for protocol simplifications and other energy saving things EXPLAIN!!! ]
